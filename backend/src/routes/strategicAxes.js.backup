const express = require('express');
const { PrismaClient } = require('@prisma/client');
const authenticateToken = require('../middleware/auth');
const { authorize } = require('../middleware/authorization');
const logger = require('../utils/logger');

const router = express.Router();
const prisma = new PrismaClient();

/**
 * @route   GET /api/strategic-axes
 * @desc    Obtener todos los ejes estratégicos con filtros
 * @access  Private (read:strategic_axis)
 */
router.get('/', 
  authenticateToken, 
  authorize('read', 'strategic_axis'),
  async (req, res) => {
    try {
      const { 
        year, 
        departmentId, 
        includeObjectives = false,
        includeIndicators = false,
        isActive,
        page = 1,
        limit = 50
      } = req.query;

      const skip = (parseInt(page) - 1) * parseInt(limit);
      let where = {};
      
      if (year) {
        where.year = parseInt(year);
      }
      
      if (departmentId) {
        where.departmentId = departmentId;
      }

      if (isActive !== undefined) {
        where.isActive = isActive === 'true';
      }

      // Filtrar por departamento según el rol del usuario
      const userRole = req.user.role.name;
      if (userRole === 'Director de Área') {
        where.departmentId = req.user.departmentId;
      }

      const [strategicAxes, total] = await Promise.all([
        prisma.strategicAxis.findMany({
          where,
          include: {
            department: {
              select: { 
                id: true, 
                name: true, 
                code: true 
              }
            },
            objectives: includeObjectives === 'true' ? {
              where: { isActive: true },
              include: {
                products: {
                  where: { isActive: true },
                  select: {
                    id: true,
                    name: true,
                    code: true,
                    type: true
                  }
                },
                _count: {
                  select: {
                    products: true,
                    indicators: true
                  }
                }
              }
            } : false,
            indicators: includeIndicators === 'true' ? {
              select: { 
                id: true, 
                name: true, 
                type: true,
                annualTarget: true,
                measurementUnit: true
              }
            } : false,
            _count: {
              select: { 
                objectives: true,
                indicators: true
              }
            }
          },
          skip,
          take: parseInt(limit),
          orderBy: [
            { year: 'desc' },
            { code: 'asc' }
          ]
        }),
        prisma.strategicAxis.count({ where })
      ]);

      res.json({
        success: true,
        data: strategicAxes,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total,
          pages: Math.ceil(total / parseInt(limit))
        }
      });

    } catch (error) {
      logger.error('Error al obtener ejes estratégicos:', error);
      res.status(500).json({
        success: false,
        message: 'Error interno del servidor',
        error: error.message
      });
    }
  }
);

/**
 * @route   GET /api/strategic-axes/:id
 * @desc    Obtener un eje estratégico por ID
 * @access  Private (read:strategic_axis)
 */
router.get('/:id', 
  authenticateToken, 
  authorize('read', 'strategic_axis'),
  async (req, res) => {
    try {
      const { id } = req.params;

      const strategicAxis = await prisma.strategicAxis.findUnique({
        where: { id },
        include: {
          department: {
            select: { 
              id: true, 
              name: true, 
              code: true 
            }
          },
          objectives: {
            where: { isActive: true },
            include: {
              products: {
                where: { isActive: true },
                include: {
                  activities: {
                    where: { isActive: true },
                    select: {
                      id: true,
                      name: true,
                      code: true,
                      startDate: true,
                      endDate: true
                    }
                  },
                  _count: {
                    select: {
                      activities: true,
                      indicators: true
                    }
                  }
                }
              },
              indicators: {
                select: {
                  id: true,
                  name: true,
                  type: true,
                  annualTarget: true,
                  measurementUnit: true,
                  baseline: true
                }
              },
              _count: {
                select: {
                  products: true,
                  indicators: true
                }
              }
            }
          },
          indicators: {
            select: {
              id: true,
              name: true,
              type: true,
              annualTarget: true,
              measurementUnit: true,
              baseline: true,
              q1Target: true,
              q2Target: true,
              q3Target: true,
              q4Target: true
            }
          },
          _count: {
            select: {
              objectives: true,
              indicators: true
            }
          }
        }
      });

      if (!strategicAxis) {
        return res.status(404).json({
          success: false,
          message: 'Eje estratégico no encontrado'
        });
      }

      // Verificar permisos de acceso por departamento
      const userRole = req.user.role.name;
      if (userRole === 'Director de Área' && strategicAxis.departmentId !== req.user.departmentId) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para ver este eje estratégico'
        });
      }

      res.json({
        success: true,
        data: strategicAxis
      });

    } catch (error) {
      logger.error('Error al obtener eje estratégico:', error);
      res.status(500).json({
        success: false,
        message: 'Error interno del servidor',
        error: error.message
      });
    }
  }
);

/**
 * @route   POST /api/strategic-axes
 * @desc    Crear nuevo eje estratégico
 * @access  Private (create:strategic_axis)
 */
router.post('/', 
  authenticateToken, 
  authorize('create', 'strategic_axis'),
  async (req, res) => {
    try {
      const { name, description, code, year, departmentId } = req.body;

      // Validaciones básicas
      if (!name || !code || !year) {
        return res.status(400).json({
          success: false,
          message: 'Nombre, código y año son requeridos'
        });
      }

      // Verificar que el código sea único para el año
      const existingAxis = await prisma.strategicAxis.findUnique({
        where: {
          code_year: {
            code,
            year: parseInt(year)
          }
        }
      });

      if (existingAxis) {
        return res.status(400).json({
          success: false,
          message: 'Ya existe un eje estratégico con este código para el año especificado'
        });
      }

      // Verificar que el departamento exista (si se proporciona)
      if (departmentId) {
        const department = await prisma.department.findUnique({
          where: { id: departmentId }
        });

        if (!department) {
          return res.status(400).json({
            success: false,
            message: 'Departamento no válido'
          });
        }
      }

      // Crear eje estratégico
      const newStrategicAxis = await prisma.strategicAxis.create({
        data: {
          name,
          description,
          code,
          year: parseInt(year),
          departmentId: departmentId || null
        },
        include: {
          department: {
            select: { 
              id: true, 
              name: true, 
              code: true 
            }
          }
        }
      });

      logger.info(`Eje estratégico creado: ${code} - ${name} por ${req.user.email}`);

      res.status(201).json({
        success: true,
        message: 'Eje estratégico creado exitosamente',
        data: newStrategicAxis
      });

    } catch (error) {
      logger.error('Error al crear eje estratégico:', error);
      res.status(500).json({
        success: false,
        message: 'Error interno del servidor',
        error: error.message
      });
    }
  }
);

/**
 * @route   PUT /api/strategic-axes/:id
 * @desc    Actualizar eje estratégico
 * @access  Private (update:strategic_axis)
 */
router.put('/:id', 
  authenticateToken, 
  authorize('update', 'strategic_axis'),
  async (req, res) => {
    try {
      const { id } = req.params;
      const { name, description, code, year, departmentId, isActive, isLocked } = req.body;

      // Verificar que el eje estratégico exista
      const existingAxis = await prisma.strategicAxis.findUnique({
        where: { id }
      });

      if (!existingAxis) {
        return res.status(404).json({
          success: false,
          message: 'Eje estratégico no encontrado'
        });
      }

      // Verificar si está bloqueado
      if (existingAxis.isLocked && req.user.role.name !== 'Administrador') {
        return res.status(400).json({
          success: false,
          message: 'El eje estratégico está bloqueado y no puede ser modificado'
        });
      }

      // Verificar permisos de acceso por departamento
      const userRole = req.user.role.name;
      if (userRole === 'Director de Área' && existingAxis.departmentId !== req.user.departmentId) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para editar este eje estratégico'
        });
      }

      // Verificar que el código sea único (si se está cambiando)
      if (code && (code !== existingAxis.code || (year && parseInt(year) !== existingAxis.year))) {
        const codeExists = await prisma.strategicAxis.findUnique({
          where: {
            code_year: {
              code,
              year: year ? parseInt(year) : existingAxis.year
            }
          }
        });

        if (codeExists && codeExists.id !== id) {
          return res.status(400).json({
            success: false,
            message: 'Ya existe un eje estratégico con este código para el año especificado'
          });
        }
      }

      // Verificar que el departamento exista (si se está cambiando)
      if (departmentId) {
        const department = await prisma.department.findUnique({
          where: { id: departmentId }
        });

        if (!department) {
          return res.status(400).json({
            success: false,
            message: 'Departamento no válido'
          });
        }
      }

      // Actualizar eje estratégico
      const updatedAxis = await prisma.strategicAxis.update({
        where: { id },
        data: {
          ...(name && { name }),
          ...(description !== undefined && { description }),
          ...(code && { code }),
          ...(year && { year: parseInt(year) }),
          ...(departmentId !== undefined && { departmentId }),
          ...(isActive !== undefined && { isActive }),
          ...(isLocked !== undefined && { isLocked })
        },
        include: {
          department: {
            select: { 
              id: true, 
              name: true, 
              code: true 
            }
          },
          _count: {
            select: {
              objectives: true,
              indicators: true
            }
          }
        }
      });

      logger.info(`Eje estratégico actualizado: ${updatedAxis.code} - ${updatedAxis.name} por ${req.user.email}`);

      res.json({
        success: true,
        message: 'Eje estratégico actualizado exitosamente',
        data: updatedAxis
      });

    } catch (error) {
      logger.error('Error al actualizar eje estratégico:', error);
      res.status(500).json({
        success: false,
        message: 'Error interno del servidor',
        error: error.message
      });
    }
  }
);

/**
 * @route   DELETE /api/strategic-axes/:id
 * @desc    Eliminar eje estratégico (soft delete)
 * @access  Private (delete:strategic_axis)
 */
router.delete('/:id', 
  authenticateToken, 
  authorize('delete', 'strategic_axis'),
  async (req, res) => {
    try {
      const { id } = req.params;

      // Verificar que el eje estratégico exista
      const existingAxis = await prisma.strategicAxis.findUnique({
        where: { id },
        include: {
          _count: {
            select: {
              objectives: true,
              indicators: true
            }
          }
        }
      });

      if (!existingAxis) {
        return res.status(404).json({
          success: false,
          message: 'Eje estratégico no encontrado'
        });
      }

      // Verificar si está bloqueado
      if (existingAxis.isLocked) {
        return res.status(400).json({
          success: false,
          message: 'El eje estratégico está bloqueado y no puede ser eliminado'
        });
      }

      // Verificar si tiene objetivos o indicadores asociados
      if (existingAxis._count.objectives > 0 || existingAxis._count.indicators > 0) {
        return res.status(400).json({
          success: false,
          message: `No se puede eliminar el eje estratégico porque tiene ${existingAxis._count.objectives} objetivo(s) y ${existingAxis._count.indicators} indicador(es) asociado(s)`
        });
      }

      // Verificar permisos de acceso por departamento
      const userRole = req.user.role.name;
      if (userRole === 'Director de Área' && existingAxis.departmentId !== req.user.departmentId) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para eliminar este eje estratégico'
        });
      }

      // Soft delete - marcar como inactivo
      await prisma.strategicAxis.update({
        where: { id },
        data: { isActive: false }
      });

      logger.info(`Eje estratégico desactivado: ${existingAxis.code} - ${existingAxis.name} por ${req.user.email}`);

      res.json({
        success: true,
        message: 'Eje estratégico desactivado exitosamente'
      });

    } catch (error) {
      logger.error('Error al eliminar eje estratégico:', error);
      res.status(500).json({
        success: false,
        message: 'Error interno del servidor',
        error: error.message
      });
    }
  }
);

/**
 * @route   PUT /api/strategic-axes/:id/lock
 * @desc    Bloquear/desbloquear eje estratégico
 * @access  Private (update:strategic_axis)
 */
router.put('/:id/lock', 
  authenticateToken, 
  authorize('update', 'strategic_axis'),
  async (req, res) => {
    try {
      const { id } = req.params;
      const { isLocked } = req.body;

      if (typeof isLocked !== 'boolean') {
        return res.status(400).json({
          success: false,
          message: 'El parámetro isLocked debe ser true o false'
        });
      }

      // Verificar que el eje estratégico exista
      const existingAxis = await prisma.strategicAxis.findUnique({
        where: { id }
      });

      if (!existingAxis) {
        return res.status(404).json({
          success: false,
          message: 'Eje estratégico no encontrado'
        });
      }

      // Solo Director de Planificación y Administrador pueden bloquear/desbloquear
      const userRole = req.user.role.name;
      if (!['Administrador', 'Director de Planificación'].includes(userRole)) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para bloquear/desbloquear ejes estratégicos'
        });
      }

      // Actualizar estado de bloqueo
      const updatedAxis = await prisma.strategicAxis.update({
        where: { id },
        data: { isLocked }
      });

      logger.info(`Eje estratégico ${isLocked ? 'bloqueado' : 'desbloqueado'}: ${updatedAxis.code} - ${updatedAxis.name} por ${req.user.email}`);

      res.json({
        success: true,
        message: `Eje estratégico ${isLocked ? 'bloqueado' : 'desbloqueado'} exitosamente`,
        data: updatedAxis
      });

    } catch (error) {
      logger.error('Error al cambiar estado de bloqueo:', error);
      res.status(500).json({
        success: false,
        message: 'Error interno del servidor',
        error: error.message
      });
    }
  }
);

/**
 * @route   GET /api/strategic-axes/stats/summary
 * @desc    Obtener estadísticas de ejes estratégicos
 * @access  Private (read:strategic_axis)
 */
router.get('/stats/summary', 
  authenticateToken, 
  authorize('read', 'strategic_axis'),
  async (req, res) => {
    try {
      const { year } = req.query;
      const where = {};
      
      if (year) {
        where.year = parseInt(year);
      }

      // Filtrar por departamento según el rol del usuario
      const userRole = req.user.role.name;
      if (userRole === 'Director de Área') {
        where.departmentId = req.user.departmentId;
      }

      const [
        totalAxes, 
        activeAxes, 
        lockedAxes,
        axesByYear,
        axesByDepartment
      ] = await Promise.all([
        prisma.strategicAxis.count({ where }),
        prisma.strategicAxis.count({ where: { ...where, isActive: true } }),
        prisma.strategicAxis.count({ where: { ...where, isLocked: true } }),
        prisma.strategicAxis.groupBy({
          by: ['year'],
          where,
          _count: true,
          orderBy: { year: 'desc' }
        }),
        prisma.strategicAxis.groupBy({
          by: ['departmentId'],
          where,
          _count: true
        })
      ]);

      // Obtener nombres de departamentos
      const departmentsWithCounts = await Promise.all(
        axesByDepartment.map(async (deptGroup) => {
          if (!deptGroup.departmentId) {
            return {
              departmentId: null,
              departmentName: 'Sin departamento',
              count: deptGroup._count
            };
          }
          
          const department = await prisma.department.findUnique({
            where: { id: deptGroup.departmentId },
            select: { name: true }
          });
          return {
            departmentId: deptGroup.departmentId,
            departmentName: department?.name || 'Desconocido',
            count: deptGroup._count
          };
        })
      );

      res.json({
        success: true,
        data: {
          totalAxes,
          activeAxes,
          inactiveAxes: totalAxes - activeAxes,
          lockedAxes,
          axesByYear: axesByYear.map(ag => ({
            year: ag.year,
            count: ag._count
          })),
          axesByDepartment: departmentsWithCounts
        }
      });

    } catch (error) {
      logger.error('Error al obtener estadísticas de ejes estratégicos:', error);
      res.status(500).json({
        success: false,
        message: 'Error interno del servidor',
        error: error.message
      });
    }
  }
);

module.exports = router;
      },
      orderBy: [
        { year: 'desc' },
        { code: 'asc' }
      ]
    });

    res.json(strategicAxes);
  } catch (error) {
    console.error('Error al obtener ejes estratégicos:', error);
    res.status(500).json({ 
      message: 'Error interno del servidor',
      error: error.message 
    });
  }
});

// GET /api/strategic-axes/years - Obtener años disponibles
router.get('/years', auth, async (req, res) => {
  try {
    const years = await prisma.strategicAxis.findMany({
      select: { year: true },
      distinct: ['year'],
      orderBy: { year: 'desc' }
    });

    res.json(years.map(item => item.year));
  } catch (error) {
    console.error('Error al obtener años:', error);
    res.status(500).json({ 
      message: 'Error interno del servidor',
      error: error.message 
    });
  }
});

// GET /api/strategic-axes/:id - Obtener eje estratégico específico
router.get('/:id', auth, async (req, res) => {
  try {
    const { id } = req.params;

    const strategicAxis = await prisma.strategicAxis.findUnique({
      where: { id },
      include: {
        department: {
          select: { id: true, name: true, code: true }
        },
        objectives: {
          include: {
            products: {
              select: { id: true, name: true, description: true }
            },
            indicators: {
              select: { id: true, name: true, type: true, measurementUnit: true }
            }
          },
          orderBy: { createdAt: 'asc' }
        },
        indicators: {
          select: { 
            id: true, 
            name: true, 
            type: true, 
            measurementUnit: true,
            baseline: true,
            annualTarget: true
          }
        }
      }
    });

    if (!strategicAxis) {
      return res.status(404).json({ message: 'Eje estratégico no encontrado' });
    }

    res.json(strategicAxis);
  } catch (error) {
    console.error('Error al obtener eje estratégico:', error);
    res.status(500).json({ 
      message: 'Error interno del servidor',
      error: error.message 
    });
  }
});

// POST /api/strategic-axes - Crear nuevo eje estratégico
router.post('/', auth, authorize('create', 'strategicAxis'), async (req, res) => {
  try {
    const { name, description, code, year, departmentId } = req.body;

    // Validaciones
    if (!name || name.trim().length === 0) {
      return res.status(400).json({ message: 'El nombre del eje estratégico es requerido' });
    }

    if (!code || code.trim().length === 0) {
      return res.status(400).json({ message: 'El código del eje estratégico es requerido' });
    }

    if (!year || year < 2020 || year > 2100) {
      return res.status(400).json({ message: 'El año debe estar entre 2020 y 2100' });
    }

    // Verificar que el código no esté duplicado para el mismo año
    const existingCode = await prisma.strategicAxis.findFirst({
      where: { 
        code: code.trim(),
        year: parseInt(year)
      }
    });
    if (existingCode) {
      return res.status(400).json({ 
        message: `Ya existe un eje estratégico con el código "${code}" para el año ${year}` 
      });
    }

    // Verificar que el departamento existe (si se especifica)
    if (departmentId) {
      const department = await prisma.department.findUnique({
        where: { id: departmentId }
      });
      if (!department) {
        return res.status(400).json({ message: 'El departamento especificado no existe' });
      }
    }

    const strategicAxis = await prisma.strategicAxis.create({
      data: {
        name: name.trim(),
        description: description?.trim() || null,
        code: code.trim(),
        year: parseInt(year),
        departmentId: departmentId || null
      },
      include: {
        department: {
          select: { id: true, name: true, code: true }
        }
      }
    });

    res.status(201).json({
      message: 'Eje estratégico creado exitosamente',
      strategicAxis
    });
  } catch (error) {
    console.error('Error al crear eje estratégico:', error);
    if (error.code === 'P2002') {
      return res.status(400).json({ 
        message: 'Ya existe un eje estratégico con ese código para el año especificado' 
      });
    }
    res.status(500).json({ 
      message: 'Error interno del servidor',
      error: error.message 
    });
  }
});

// PUT /api/strategic-axes/:id - Actualizar eje estratégico
router.put('/:id', auth, authorize('update', 'strategicAxis'), async (req, res) => {
  try {
    const { id } = req.params;
    const { name, description, code, year, departmentId, isActive } = req.body;

    // Verificar que el eje estratégico existe
    const existingAxis = await prisma.strategicAxis.findUnique({
      where: { id }
    });
    if (!existingAxis) {
      return res.status(404).json({ message: 'Eje estratégico no encontrado' });
    }

    // Verificar si está bloqueado
    if (existingAxis.isLocked) {
      return res.status(400).json({ 
        message: 'No se puede modificar un eje estratégico bloqueado. Debe desbloquearlo primero.' 
      });
    }

    // Validaciones
    if (name && name.trim().length === 0) {
      return res.status(400).json({ message: 'El nombre del eje estratégico no puede estar vacío' });
    }

    if (code && code.trim().length === 0) {
      return res.status(400).json({ message: 'El código del eje estratégico no puede estar vacío' });
    }

    if (year && (year < 2020 || year > 2100)) {
      return res.status(400).json({ message: 'El año debe estar entre 2020 y 2100' });
    }

    // Verificar duplicados solo si cambiaron
    if ((code && code !== existingAxis.code) || (year && year !== existingAxis.year)) {
      const existingCode = await prisma.strategicAxis.findFirst({
        where: { 
          code: code?.trim() || existingAxis.code,
          year: parseInt(year) || existingAxis.year,
          id: { not: id }
        }
      });
      if (existingCode) {
        return res.status(400).json({ 
          message: `Ya existe un eje estratégico con el código "${code || existingAxis.code}" para el año ${year || existingAxis.year}` 
        });
      }
    }

    // Verificar que el departamento existe (si se especifica)
    if (departmentId && departmentId !== existingAxis.departmentId) {
      const department = await prisma.department.findUnique({
        where: { id: departmentId }
      });
      if (!department) {
        return res.status(400).json({ message: 'El departamento especificado no existe' });
      }
    }

    const strategicAxis = await prisma.strategicAxis.update({
      where: { id },
      data: {
        name: name?.trim() || existingAxis.name,
        description: description?.trim() || existingAxis.description,
        code: code?.trim() || existingAxis.code,
        year: parseInt(year) || existingAxis.year,
        departmentId: departmentId !== undefined ? departmentId : existingAxis.departmentId,
        isActive: isActive !== undefined ? isActive : existingAxis.isActive
      },
      include: {
        department: {
          select: { id: true, name: true, code: true }
        },
        _count: {
          select: { 
            objectives: true,
            indicators: true
          }
        }
      }
    });

    res.json({
      message: 'Eje estratégico actualizado exitosamente',
      strategicAxis
    });
  } catch (error) {
    console.error('Error al actualizar eje estratégico:', error);
    if (error.code === 'P2002') {
      return res.status(400).json({ 
        message: 'Ya existe un eje estratégico con ese código para el año especificado' 
      });
    }
    res.status(500).json({ 
      message: 'Error interno del servidor',
      error: error.message 
    });
  }
});

// PUT /api/strategic-axes/:id/lock - Bloquear/Desbloquear eje estratégico
router.put('/:id/lock', auth, authorize('update', 'strategicAxis'), async (req, res) => {
  try {
    const { id } = req.params;
    const { isLocked } = req.body;

    const strategicAxis = await prisma.strategicAxis.findUnique({
      where: { id }
    });

    if (!strategicAxis) {
      return res.status(404).json({ message: 'Eje estratégico no encontrado' });
    }

    const updatedAxis = await prisma.strategicAxis.update({
      where: { id },
      data: { isLocked: isLocked === true },
      include: {
        department: {
          select: { id: true, name: true, code: true }
        }
      }
    });

    res.json({
      message: `Eje estratégico ${isLocked ? 'bloqueado' : 'desbloqueado'} exitosamente`,
      strategicAxis: updatedAxis
    });
  } catch (error) {
    console.error('Error al cambiar estado de bloqueo:', error);
    res.status(500).json({ 
      message: 'Error interno del servidor',
      error: error.message 
    });
  }
});

// DELETE /api/strategic-axes/:id - Eliminar eje estratégico
router.delete('/:id', auth, authorize('delete', 'strategicAxis'), async (req, res) => {
  try {
    const { id } = req.params;

    // Verificar que el eje estratégico existe
    const strategicAxis = await prisma.strategicAxis.findUnique({
      where: { id },
      include: {
        objectives: true,
        indicators: true
      }
    });

    if (!strategicAxis) {
      return res.status(404).json({ message: 'Eje estratégico no encontrado' });
    }

    // Verificar si está bloqueado
    if (strategicAxis.isLocked) {
      return res.status(400).json({ 
        message: 'No se puede eliminar un eje estratégico bloqueado' 
      });
    }

    // Verificar que no tenga dependencias
    if (strategicAxis.objectives.length > 0) {
      return res.status(400).json({ 
        message: `No se puede eliminar el eje estratégico porque tiene ${strategicAxis.objectives.length} objetivo(s) asociado(s)` 
      });
    }

    if (strategicAxis.indicators.length > 0) {
      return res.status(400).json({ 
        message: `No se puede eliminar el eje estratégico porque tiene ${strategicAxis.indicators.length} indicador(es) asociado(s)` 
      });
    }

    await prisma.strategicAxis.delete({
      where: { id }
    });

    res.json({ message: 'Eje estratégico eliminado exitosamente' });
  } catch (error) {
    console.error('Error al eliminar eje estratégico:', error);
    res.status(500).json({ 
      message: 'Error interno del servidor',
      error: error.message 
    });
  }
});

module.exports = router;
